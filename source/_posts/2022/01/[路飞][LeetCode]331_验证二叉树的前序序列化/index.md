---
theme: condensed-night-purple
---

看一百遍美女，美女也不一定是你的。但你刷一百遍算法，知识就是你的了~~

谁能九层台，不用累土起!

[题目地址](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

<!-- more -->


## 题目

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

```
    _9_
    /   \
   3     2
  / \   / \
 4   1  #  6
/ \ / \   / \
# # # #   # #
```

例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。

**示例 1:**

```
输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

**示例 2:**

```
输入: "1,#"
输出: false
```

**示例 3:**

```
输入: "9,#,#,1"
输出: false
```


## 解题思路

- 我们用`#`来填充空节点因此在本题中我们可以认为
- 一个非空节点有两个子节点, 空节点(也就是`#`)没有子节点
- 我们定义一个计数器用来记录槽点的个数并默认为头节点的`1`
- 我们对树进行遍历，每遍历到一个节点，我们将槽点的个数`-1`
- 如果一个节点是数字，我们可以认为他需要两个槽点来放置子节点
- 如果是正确的二叉树的前序序列化，那么可以完成遍历并且最终槽点个数为`0`

## 解题代码

```js
var isValidSerialization = function(preorder) {
    let num = 1
    let odlist = preorder.split(',')
    for(let i =0;i<odlist.length;i++){
        if(num==0) return false
        num--
        if(odlist[i]!='#') num+=2
    }
    return num ==0
};
```

如有任何问题或建议，欢迎留言讨论！